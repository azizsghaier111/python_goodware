{"imports": ["collections", "pywrap_tfe", "context", "core", "execute", "dtypes", "annotation_types", "op_def_registry", "ops", "op_def_library", "deprecated_endpoints", "dispatch", "tf_export", "TypeVar", "List", "Any", "Annotated"], "function_calls": ["TypeVar", "TypeVar", "namedtuple", "TypeVar", "namedtuple", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "TypeVar", "context", "tf_export", "to_raw_op", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "execute", "must_record_gradient", "_make", "context", "tf_export", "to_raw_op", "execute", "must_record_gradient", "_make", "context", "tf_export", "to_raw_op", "make_type", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "make_type", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "args_to_matching_eager", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "make_type", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "context", "tf_export", "to_raw_op", "make_type", "convert_to_tensor", "convert_to_tensor", "convert_to_tensor", "execute", "must_record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient", "record_gradient"], "strings": ["Python wrappers around TensorFlow ops.\n\nThis file is MACHINE GENERATED! Do not edit.\n", "TV_StatelessRandomGammaV3_dtype", "TV_StatelessRandomGammaV3_shape_dtype", "Outputs deterministic pseudorandom random numbers from a gamma distribution.\n\n  Outputs random values from a gamma distribution.\n\n  The outputs are a deterministic function of the inputs.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    alpha: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`.\n      The concentration of the gamma distribution. Shape must match the rightmost\n      dimensions of `shape`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor`. Has the same type as `alpha`.\n  ", "Picks the best counter-based RNG algorithm based on device.\n\n  This op picks the best counter-based RNG algorithm based on device.\n\n  Args:\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `int32`.\n  ", "StatelessRandomGetKeyCounter", "TV_StatelessRandomGetKeyCounter_Tseed", "Scrambles seed into key and counter, using the best algorithm based on device.\n\n  This op scrambles a shape-[2] seed into a key and a counter, both needed by counter-based RNG algorithms. The scrambing uses the best algorithm based on device. The scrambling is opaque but approximately satisfies the property that different seed results in different key/counter pair (which will in turn result in different random numbers).\n\n  Args:\n    seed: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      2 seeds (shape [2]).\n    name: A name for the operation (optional).\n\n  Returns:\n    A tuple of `Tensor` objects (key, counter).\n\n    key: A `Tensor` of type `uint64`.\n    counter: A `Tensor` of type `uint64`.\n  ", "StatelessRandomGetKeyCounterAlg", "TV_StatelessRandomGetKeyCounterAlg_Tseed", "Picks the best algorithm based on device, and scrambles seed into key and counter.\n\n  This op picks the best counter-based RNG algorithm based on device, and scrambles a shape-[2] seed into a key and a counter, both needed by the counter-based algorithm. The scrambling is opaque but approximately satisfies the property that different seed results in different key/counter pair (which will in turn result in different random numbers).\n\n  Args:\n    seed: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      2 seeds (shape [2]).\n    name: A name for the operation (optional).\n\n  Returns:\n    A tuple of `Tensor` objects (key, counter, alg).\n\n    key: A `Tensor` of type `uint64`.\n    counter: A `Tensor` of type `uint64`.\n    alg: A `Tensor` of type `int32`.\n  ", "TV_StatelessRandomNormalV2_dtype", "TV_StatelessRandomNormalV2_Tshape", "Outputs deterministic pseudorandom values from a normal distribution.\n\n  The generated values will have mean 0 and standard deviation 1.\n\n  The outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    dtype: An optional `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`. Defaults to `tf.float32`.\n      The type of the output.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `dtype`.\n  ", "TV_StatelessRandomUniformFullIntV2_dtype", "TV_StatelessRandomUniformFullIntV2_Tshape", "Outputs deterministic pseudorandom random integers from a uniform distribution.\n\n  The generated values are uniform integers covering the whole range of `dtype`.\n\n  The outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    dtype: An optional `tf.DType` from: `tf.int32, tf.int64, tf.uint32, tf.uint64`. Defaults to `tf.uint64`.\n      The type of the output.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `dtype`.\n  ", "TV_StatelessRandomUniformIntV2_dtype", "TV_StatelessRandomUniformIntV2_Tshape", "Outputs deterministic pseudorandom random integers from a uniform distribution.\n\n  The generated values follow a uniform distribution in the range `[minval, maxval)`.\n\n  The outputs are a deterministic function of `shape`, `key`, `counter`, `alg`, `minval` and `maxval`.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    minval: A `Tensor`. Must be one of the following types: `int32`, `int64`, `uint32`, `uint64`.\n      Minimum value (inclusive, scalar).\n    maxval: A `Tensor`. Must have the same type as `minval`.\n      Maximum value (exclusive, scalar).\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor`. Has the same type as `minval`.\n  ", "TV_StatelessRandomUniformV2_dtype", "TV_StatelessRandomUniformV2_Tshape", "Outputs deterministic pseudorandom random values from a uniform distribution.\n\n  The generated values follow a uniform distribution in the range `[0, 1)`. The\n  lower bound 0 is included in the range, while the upper bound 1 is excluded.\n\n  The outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    dtype: An optional `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`. Defaults to `tf.float32`.\n      The type of the output.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `dtype`.\n  ", "TV_StatelessShuffle_T", "Randomly and deterministically shuffles a tensor along its first dimension.\n\n  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n  ```\n  [[1, 2],       [[5, 6],\n   [3, 4],  ==>   [1, 2],\n   [5, 6]]        [3, 4]]\n  ```\n\n  The outputs are a deterministic function of `value`, `key`, `counter` and `alg`.\n\n  Args:\n    value: A `Tensor`. The tensor to be shuffled.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor`. Has the same type as `value`.\n  ", "TV_StatelessTruncatedNormalV2_dtype", "TV_StatelessTruncatedNormalV2_Tshape", "Outputs deterministic pseudorandom values from a truncated normal distribution.\n\n  The generated values follow a normal distribution with mean 0 and standard\n  deviation 1, except that values whose magnitude is more than 2 standard\n  deviations from the mean are dropped and re-picked.\n\n  The outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.\n\n  Args:\n    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      The shape of the output tensor.\n    key: A `Tensor` of type `uint64`.\n      Key for the counter-based RNG algorithm (shape uint64[1]).\n    counter: A `Tensor` of type `uint64`.\n      Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.\n    alg: A `Tensor` of type `int32`. The RNG algorithm (shape int32[]).\n    dtype: An optional `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`. Defaults to `tf.float32`.\n      The type of the output.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `dtype`.\n  ", "shape", "key", "counter", "alg", "alpha", "return", "raw_ops.StatelessRandomGammaV3", "shape", "key", "counter", "alg", "alpha", "return", "dtype", "shape_dtype", "raw_ops.StatelessRandomGetAlg", "key", "counter", "raw_ops.StatelessRandomGetKeyCounter", "Tseed", "key", "counter", "alg", "raw_ops.StatelessRandomGetKeyCounterAlg", "Tseed", "shape", "key", "counter", "alg", "dtype", "return", "raw_ops.StatelessRandomNormalV2", "shape", "key", "counter", "alg", "dtype", "return", "dtype", "dtype", "Tshape", "shape", "key", "counter", "alg", "dtype", "return", "raw_ops.StatelessRandomUniformFullIntV2", "shape", "key", "counter", "alg", "dtype", "return", "dtype", "dtype", "Tshape", "shape", "key", "counter", "alg", "minval", "maxval", "return", "raw_ops.StatelessRandomUniformIntV2", "shape", "key", "counter", "alg", "minval", "maxval", "return", "dtype", "Tshape", "shape", "key", "counter", "alg", "dtype", "return", "raw_ops.StatelessRandomUniformV2", "shape", "key", "counter", "alg", "dtype", "return", "dtype", "dtype", "Tshape", "value", "key", "counter", "alg", "return", "raw_ops.StatelessShuffle", "value", "key", "counter", "alg", "return", "T", "shape", "key", "counter", "alg", "dtype", "return", "raw_ops.StatelessTruncatedNormalV2", "shape", "key", "counter", "alg", "dtype", "return", "dtype", "dtype", "Tshape", "StatelessRandomGammaV3", "StatelessRandomGetAlg", "StatelessRandomGetKeyCounter", "StatelessRandomGetKeyCounterAlg", "StatelessRandomNormalV2", "StatelessRandomUniformFullIntV2", "StatelessRandomUniformIntV2", "StatelessRandomUniformV2", "StatelessShuffle", "StatelessTruncatedNormalV2", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name", "inputs", "attrs", "ctx", "name"]}