{"imports": ["os", "time", "sys", "zlib", "BytesIO", "warnings", "numpy", "scipy.sparse", "native_code", "swapped_code", "MatFileReader", "docfiller", "matdims", "read_dtype", "arr_to_chars", "arr_dtype_number", "MatWriteError", "MatReadError", "MatReadWarning", "VarReader5", "MatlabObject", "MatlabFunction", "MDTYPES", "NP_TO_MTYPES", "NP_TO_MXTYPES", "miCOMPRESSED", "miMATRIX", "miINT8", "miUTF8", "miUINT32", "mxCELL_CLASS", "mxSTRUCT_CLASS", "mxOBJECT_CLASS", "mxCHAR_CLASS", "mxSPARSE_CLASS", "mxDOUBLE_CLASS", "mclass_info", "mat_struct", "ZlibInputStream"], "function_calls": ["isinstance", "isinstance", "isinstance", "_has_struct", "append", "isinstance", "_has_struct", "isinstance", "_has_struct", "__init__", "seek", "read", "seek", "read_dtype", "strip", "VarReader5", "VarReader5", "read_full_tag", "append", "append", "_matstruct_to_dict", "_inspect_cell_array", "_matstruct_to_dict", "_inspect_cell_array", "getdefaultencoding", "ValueError", "_matstruct_to_dict", "_inspect_cell_array", "super", "item"], "strings": [" Classes for read / write of matlab (TM) 5 files\n\nThe matfile specification last found here:\n\nhttps://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf\n\n(as of December 5 2008)\n\n=================================\n Note on functions and mat files\n=================================\n\nThe document above does not give any hints as to the storage of matlab\nfunction handles, or anonymous function handles. I had, therefore, to\nguess the format of matlab arrays of ``mxFUNCTION_CLASS`` and\n``mxOPAQUE_CLASS`` by looking at example mat files.\n\n``mxFUNCTION_CLASS`` stores all types of matlab functions. It seems to\ncontain a struct matrix with a set pattern of fields. For anonymous\nfunctions, a sub-fields of one of these fields seems to contain the\nwell-named ``mxOPAQUE_CLASS``. This seems to contain:\n\n* array flags as for any matlab matrix\n* 3 int8 strings\n* a matrix\n\nIt seems that whenever the mat file contains a ``mxOPAQUE_CLASS``\ninstance, there is also an un-named matrix (name == '') at the end of\nthe mat file. I'll call this the ``__function_workspace__`` matrix.\n\nWhen I saved two anonymous functions in a mat file, or appended another\nanonymous function to the mat file, there was still only one\n``__function_workspace__`` un-named matrix at the end, but larger than\nthat for a mat file with a single anonymous function, suggesting that\nthe workspaces for the two functions had been merged.\n\nThe ``__function_workspace__`` matrix appears to be of double class\n(``mxCLASS_DOUBLE``), but stored as uint8, the memory for which is in\nthe format of a mini .mat file, without the first 124 bytes of the file\nheader (the description and the subsystem_offset), but with the version\nU2 bytes, and the S2 endian test bytes. There follow 4 zero bytes,\npresumably for 8 byte padding, and then a series of ``miMATRIX``\nentries, as in a standard mat file. The ``miMATRIX`` entries appear to\nbe series of un-named (name == '') matrices, and may also contain arrays\nof this same mini-mat format.\n\nI guess that:\n\n* saving an anonymous function back to a mat file will need the\n  associated ``__function_workspace__`` matrix saved as well for the\n  anonymous function to work correctly.\n* appending to a mat file that has a ``__function_workspace__`` would\n  involve first pulling off this workspace, appending, checking whether\n  there were any more anonymous functions appended, and then somehow\n  merging the relevant workspaces, and saving at the end of the mat\n  file.\n\nThe mat files I was playing with are in ``tests/data``:\n\n* sqr.mat\n* parabola.mat\n* some_functions.mat\n\nSee ``tests/test_mio.py:test_mio_funcs.py`` for the debugging\nscript I was working with.\n\nSmall fragments of current code adapted from matfile.py by Heiko\nHenkelmann; parts of the code for simplify_cells=True adapted from\nhttp://blog.nephics.com/2019/08/28/better-loadmat-for-scipy/.\n", "Determine if elem is an array and if first array item is a struct.", "Construct lists from cell arrays (loaded as numpy ndarrays), recursing\n    into items if they contain mat_struct objects.", "Construct nested dicts from mat_struct objects.", "Convert mat objects in dict to nested dicts.", " Reader for Mat 5 mat files\n    Adds the following attribute to base class\n\n    uint16_codec - char codec to use for uint16 char arrays\n        (defaults to system default codec)\n\n    Uses variable reader that has the following standard interface (see\n    abstract class in ``miobase``::\n\n       __init__(self, file_reader)\n       read_header(self)\n       array_from_header(self)\n\n    and added interface::\n\n       set_stream(self, stream)\n       read_full_tag(self)\n\n    ", "Initializer for matlab 5 file format reader\n\n    %(matstream_arg)s\n    %(load_args)s\n    %(struct_arg)s\n    uint16_codec : {None, string}\n        Set codec to use for uint16 char arrays (e.g., 'utf-8').\n        Use system default codec if None\n        ", " Guess byte order.\n        Sets stream pointer to 0", ">", " Read in mat 5 file header ", " Run when beginning read of variables\n\n        Sets up readers from parameters in `self`\n        ", " Read header, return header, next position\n\n        Header has to define at least .name and .is_global\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        header : object\n           object that can be passed to self.read_var_array, and that\n           has attributes .name and .is_global\n        next_position : int\n           position in stream of next variable\n        ", "<", "file_header", "__header__", "__version__", "%d.%d", "dtypes", "version", "version", "Did not read any bytes", "description"]}